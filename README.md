# EPAi - Assignment 4

## Problem Description 
1. Write a Qualean class that is inspired by Boolean+Quantum concepts. We can assign it only 3 possible real states. ```[True, False, Maybe] (1, 0, -1) ``` but it internally picks an imaginary state. The moment you assign it a real number, it immediately finds an imaginary number random.uniform(-1, 1) and multiplies with it and stores that number internally after using Bankers rounding to 10th decimal place. 
It implements these functions (with exactly the same names)

``` __and__,  __or__, __repr__, __str__, __add__, __eq__, __float__, __ge__, __gt__, __invertsign__, __le__, __lt__, __mul__, __sqrt__, __bool__ ```

2. Unit test file must contain at least 25 tests, and they must not be repetitive. Some of the tests it must implement are:

 * q + q + q ... 100 times = 100 * q
 * ```q.__sqrt__() = Decimal(q).sqrt```
 * sum of 1 million different qs is very close to zero (use isclose)
 * q1 and q2 returns False when q2 is not defined as well as q1 is False
 * q1 or q2 returns True when q2 is not defined as well as q1 is not False


## Solution 
A total of 15 functions & 32 unit tests were implemented. 

### Magic Functions

1.  ```__and__``` :
Logical AND was implemented only for Qualean objects. In order to do this, we check if the other object is a Qualean object and if that is the case, we perform logical AND on the imaginary values of the two objects (generated by the product of random number and real value inputted by user), else it returns ```False```.

2. ```__or__``` :
Logical OR was implemented only for Qualean objects. In order to do this, we check if the other object is a Qualean object and if that is the case, we perform logical OR on the imaginary values of the two objects (generated by the product of random number and real value inputted by user), else it returns ```False```.

3. ```__repr__``` :
Since ```repr``` is used for debugging purposes, it was designed to return the imaginary value(generated by the product of random number and real value inputted by user) since this is the most important attribute of the Qualean object. 

4. ```__str__``` :
Since ```str``` is for end user, it was designed to display object type, state and imaginary value of the Qualean object. 

5. ```__add__``` :
Addition between Qualean objects as well as addition between Qualean and Decimal objects is facilitated for easier addition operations. 

Addition with any other type of object raises a ```ValueError```

6. ```__eq__``` :
Equality is implemented for objects of Qualean type and Boolean type. Comparison with any other type of object raises a ```TypeError```

7. ```__float__``` :
This method allows the user to convert the imaginary value to ```float```. Imaginary value is stored as a decimal with precision = 10 by default. 

8. ```__ge__``` : 
This method compares two Qualean objects to check if one object is greater than or equal to the other. If the objects being compared are not of Qualean type, ```TypeError``` is raised. 

9. ```__gt__``` :
This method compares two Qualean objects to check if one object is greater than the other. If the objects being compared are not of Qualean type, ```TypeError``` is raised. 

10. ```__invertsign__``` :
This method inverts the sign of the imaginary value. This is implemented using the ```copy_negate()``` method. 

11. ```__le__``` :
This method compares two Qualean objects to check if one object is lesser than or equal to the other. If the objects being compared are not of Qualean type, ```TypeError``` is raised.

12. ```__lt__``` :
This method compares two Qualean objects to check if one object is lesser thanthe other. If the objects being compared are not of Qualean type, ```TypeError``` is raised.

13. ```__mul__``` :
Multiplication between Qualean objects is implemented. Multiplication with any other type of object raises a ```ValueError```

14. ```__sqrt__``` :
Square root is implemented using the ```sqrt``` method from ```decimal``` package. Square root of imaginary numbers is returned. Square root of negative imaginary numbers returns a complex number. 

15. ```__bool__``` :
This returns ```False``` for Qualean(0) and ```True``` for any other value(ie, Qualean(1) or Qualean(-1)). 

16. ```__init__``` :
This function initialises the Qualean object. 

17. ```__new__```:
This function is used because we are subclassing from ```int``` class. Since int class is an immutable class, we will need to create the __new__ magic function in order for our subclassing to work as expected. 

[Reference](https://jfine-python-classes.readthedocs.io/en/latest/subclass-int.html)

### Tests 

```test_readme_exists```, ```test_readme_contents```, ```test_readme_proper_description```, ```test_readme_file_for_formatting``` :
These were implemented to test if the README.md file for the project contained proper formatting and descriptions for all the functions and tests. 

```test_mandatory1``` : 
This test checks if the following condition is implemented correctly : 
 * q + q + q ... 100 times = 100 * q 

```test_mandatory2``` :
This test checks if the following condition is implemented correctly : 
* ```q.__sqrt__() = Decimal(q).sqrt```

```test_mandatory3``` : 
This test checks if the following condition is implemented correctly : 
* sum of 1 million different qs is very close to zero (use isclose)

We use isclose to check if the sum of a million randomly generated Qualean objects is close to zero. Here we use the ```isclose``` function from the ```math``` package. Further we use an absolute tolerance (```abs_tol```) of 1000. This is because we are drawing from a random uniform distribution between [-1, 1] and hence we might get a low negative or positive number as the sum. If we think of it 1000 is only ```0.1% of 1,000,000```. Hence we are justified in using this tolerance. Realistically we observe values in the range of [-500, 500] but we are being safe by choosing 1000 as our tolerance value. 

```test_mandatory4```
This test checks if the following short circuiting condition is implemented correctly : 
* q1 and q2 returns False when q2 is not defined as well as q1 is False

```test_mandatory5``` :
This test checks if the following short circuiting condition is implemented correctly :
 * q1 or q2 returns True when q2 is not defined as well as q1 is not False

 ```test_add```, ```test_mul``` : 
 These tests check for correct implementation of addition and multiplication between Qualean objects. 

```test_logical_and```, ```test_logical_or``` :
 These tests check for correct implementation of logical AND, logical OR between Qualean objects.

 ```test_repr```,  ```test_str``` :
  These tests check for correct implementation of ```__repr__``` and ```__str__``` magic functions of Qualean class.

  ```test_equality```, ```test_ge```, ```test_gt```, ```test_le```, ```test_lt``` : 
  These tests check the implementation of ```==```, ```>=```, ```>```, ```<=```, ```<``` comparison operators between Qualean objects. 

  ```test_float``` :
  This function checks the convertion of imaginary values to float values. 

  ```test_invertsign``` :
   This function checks the invertion of sign of imaginary values in the Qualean object.

   ```test_bool``` :
   This test checks if Qualean(0) returns ```False``` as it should and if Qualean(1) or Qualean(-1) return ```True``` as they should. 

   ```test_add_with_exceptions```, ```test_eq_with_exceptions```, 
   ```test_ge_with_exceptions```, 
   ```test_gt_with_exceptions```, 
   ```test_le_with_exceptions```, 
   ```test_lt_with_exceptions```, 
   ```test_mul_with_exceptions``` : 
   These functions test if the magic functions we had implemented handle exceptions as we expect them to, for various use cases. 

   ```test_complex``` : 
   This function check if the square root of a negative imaginary number returns a complex number. 

